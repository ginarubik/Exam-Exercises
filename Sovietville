import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {

    public static void main(String[] args) {
        new Engine().run();
    }
}

// Engine Center

class Engine {

    private final Scanner scanner = new Scanner(System.in);
    private final SovietVille.City city = new SovietVille.City();
    private int incomeCounter = 0;

    public void run() {

        while (true) {

            String input = scanner.nextLine().trim();

            if (input.equalsIgnoreCase("quit")) {
                System.out.println("Total population: "
                        + city.getTotalPopulation());
                return;
            }

            try {

                Command command = CommandParser.parse(input);
                command.execute(city);

                if (command.triggersIncome()) {
                    incomeCounter++;
                    if (incomeCounter % 4 == 0) {
                        city.payIncomes();
                    }
                }

            } catch (IllegalArgumentException ex) {
                System.out.println("Invalid command: "
                        + ex.getMessage());
            }
        }
    }
}

// Pattern

interface Command {
    void execute(SovietVille.City city);
    default boolean triggersIncome() { return false; }
}

class AddHomeCommand implements Command {

    private final SovietVille.Home home;

    public AddHomeCommand(SovietVille.Home home) {
        this.home = home;
    }

    @Override
    public void execute(SovietVille.City city) {
        city.addHome(home);
    }

    @Override
    public boolean triggersIncome() {
        return true;
    }
}

class StatusCommand implements Command {

    @Override
    public void execute(SovietVille.City city) {
        city.printStatus();
    }
}

class BillsCommand implements Command {

    @Override
    public void execute(SovietVille.City city) {
        city.payBills();
    }
}

// Parser

class CommandParser {

    public static Command parse(String input) {

        if (input.equals("status"))
            return new StatusCommand();

        if (input.equals("bills"))
            return new BillsCommand();

        if (input.startsWith("YoungCoupleWithChildren"))
            return new AddHomeCommand(parseYoungCoupleWithChildren(input));

        if (input.startsWith("YoungCouple"))
            return new AddHomeCommand(parseCouple(input, 2, 20));

        if (input.startsWith("YoungSingle"))
            return new AddHomeCommand(parseSingle(input, 1, 10));

        if (input.startsWith("OldCouple"))
            return new AddHomeCommand(parseCouple(input, 3, 15));

        if (input.startsWith("OldSingle"))
            return new AddHomeCommand(parseSingle(input, 1, 15));

        throw new IllegalArgumentException("Unknown command");
    }

    private static SovietVille.Home parseSingle(String input,
                                                int rooms,
                                                double roomCost) {

        double salary = extractNumbers(input, 1)[0];

        if (rooms == 1 && roomCost == 10)
            return new SovietVille.YoungSingle(salary);

        return new SovietVille.OldSingle(salary);
    }

    private static SovietVille.Home parseCouple(String input,
                                                int rooms,
                                                double roomCost) {

        double[] values = extractNumbers(input, 2);

        if (rooms == 2)
            return new SovietVille.YoungCouple(values[0], values[1]);

        return new SovietVille.OldCouple(values[0], values[1]);
    }

    private static SovietVille.Home parseYoungCoupleWithChildren(String input) {

        double[] salaries = extractNumbers(input, 2);
        SovietVille.YoungCoupleWithChildren home =
                new SovietVille.YoungCoupleWithChildren(salaries[0], salaries[1]);

        Pattern childPattern = Pattern.compile("Child\\(([^)]+)\\)");
        Matcher matcher = childPattern.matcher(input);

        while (matcher.find()) {

            String[] parts = matcher.group(1).split(",\\s*");
            double food = Double.parseDouble(parts[0]);

            List<Double> toys = new ArrayList<>();
            for (int i = 1; i < parts.length; i++)
                toys.add(Double.parseDouble(parts[i]));

            home.addChild(new SovietVille.Child(food, toys));
        }

        return home;
    }

    private static double[] extractNumbers(String input, int expected) {

        String inside =
                input.substring(input.indexOf("(") + 1,
                        input.lastIndexOf(")"));

        String[] parts = inside.split(",\\s*");

        if (parts.length < expected)
            throw new IllegalArgumentException("Wrong parameters");

        double[] result = new double[expected];

        for (int i = 0; i < expected; i++) {
            result[i] = Double.parseDouble(parts[i]);
            if (result[i] < 0)
                throw new IllegalArgumentException("Negative values not allowed");
        }

        return result;
    }
}

// Domain

class SovietVille {

    static final double FRIDGE_COST = 1.5;
    static final double STOVE_COST = 1.2;
    static final double TV_COST = 1.0;
    static final double COMPUTER_COST = 0.7;

    // City

    static class City {

        private final List<Home> homes = new ArrayList<>();

        public void addHome(Home home) {
            homes.add(home);
        }

        public void payIncomes() {
            homes.forEach(Home::receiveIncome);
        }

        public void payBills() {

            Iterator<Home> iterator = homes.iterator();

            while (iterator.hasNext()) {
                if (!iterator.next().payBills())
                    iterator.remove();
            }
        }

        public void printStatus() {

            double total = homes.stream()
                    .mapToDouble(Home::getMonthlyConsumption)
                    .sum();

            System.out.printf("Total consumption: %.2f%n", total);
        }

        public int getTotalPopulation() {
            return homes.stream()
                    .mapToInt(Home::getPopulation)
                    .sum();
        }
    }

    // Home Base

    static abstract class Home {

        private final double income;
        private double budget;
        private final int rooms;
        private final double roomCost;

        protected Home(double income, int rooms, double roomCost) {
            this.income = income;
            this.rooms = rooms;
            this.roomCost = roomCost;
        }

        protected double getRoomsCost() {
            return rooms * roomCost;
        }

        public void receiveIncome() {
            budget += income;
        }

        public boolean payBills() {

            double monthly = getMonthlyConsumption();

            if (budget >= monthly) {
                budget -= monthly;
                return true;
            }
            return false;
        }

        abstract double getMonthlyConsumption();
        abstract int getPopulation();
    }

    // Home Types

    static class YoungSingle extends Home {
        public YoungSingle(double salary) {
            super(salary, 1, 10);
        }

        double getMonthlyConsumption() {
            return getRoomsCost() + COMPUTER_COST;
        }

        int getPopulation() { return 1; }
    }

    static class OldSingle extends Home {
        public OldSingle(double pension) {
            super(pension, 1, 15);
        }

        double getMonthlyConsumption() {
            return getRoomsCost() + STOVE_COST;
        }

        int getPopulation() { return 1; }
    }

    static class YoungCouple extends Home {
        public YoungCouple(double s1, double s2) {
            super(s1 + s2, 2, 20);
        }

        double getMonthlyConsumption() {
            return getRoomsCost()
                    + TV_COST
                    + FRIDGE_COST
                    + 2 * COMPUTER_COST;
        }

        int getPopulation() { return 2; }
    }

    static class OldCouple extends Home {
        public OldCouple(double p1, double p2) {
            super(p1 + p2, 3, 15);
        }

        double getMonthlyConsumption() {
            return getRoomsCost()
                    + TV_COST
                    + FRIDGE_COST
                    + STOVE_COST;
        }

        int getPopulation() { return 2; }
    }

    static class YoungCoupleWithChildren extends Home {

        private final List<Child> children = new ArrayList<>();

        public YoungCoupleWithChildren(double s1, double s2) {
            super(s1 + s2, 2, 30);
        }

        public void addChild(Child child) {
            children.add(child);
        }

        double getMonthlyConsumption() {

            double childrenCost = children.stream()
                    .mapToDouble(Child::getMonthlyCost)
                    .sum();

            return getRoomsCost()
                    + TV_COST
                    + FRIDGE_COST
                    + 2 * COMPUTER_COST
                    + childrenCost;
        }

        int getPopulation() {
            return 2 + children.size();
        }
    }

    static class Child {

        private final double foodCost;
        private final double toysCost;

        public Child(double foodCost, List<Double> toys) {

            if (foodCost < 0)
                throw new IllegalArgumentException("Food cannot be negative");

            this.foodCost = foodCost;
            this.toysCost = toys.stream()
                    .mapToDouble(Double::doubleValue)
                    .sum();
        }

        public double getMonthlyCost() {
            return foodCost + toysCost;
        }
    }
}
