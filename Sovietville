import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {

    public static void main(String[] args) {

        // ===== MANUAL TESTS =====
        runTests();

        // ===== PROGRAM START =====
        System.out.println("BREAKPOINT: Entering Main");
        Engine engine = new Engine();
        engine.run();
        System.out.println("BREAKPOINT: Exiting Main");
    }

    // Simple test runner instead of JUnit
    private static void runTests() {
        System.out.println("Running manual tests...");

        // Test 1: YoungCouple consumption
        SovietVille.YoungCouple home =
                new SovietVille.YoungCouple(100, 100);
        double expected = 40 + 1.0 + 1.5 + 1.4;
        assertEqual(expected, home.getMonthlyConsumption(), "YoungCouple consumption");

        // Test 2: Child cost
        SovietVille.Child child =
                new SovietVille.Child(10, Arrays.asList(5.0, 5.0));
        assertEqual(20, child.getMonthlyCost(), "Child cost");

        // Test 3: Budget decreases after bills
        SovietVille.YoungSingle single =
                new SovietVille.YoungSingle(100);
        single.receiveIncome();
        double before = single.getBudget();
        single.payBills();
        if (single.getBudget() < before) {
            System.out.println("✔ Budget decreases after bills");
        } else {
            System.out.println("✘ Budget did not decrease");
        }

        // Test 4: Home removed if cannot pay
        SovietVille.City city = new SovietVille.City();
        city.processCommand("YoungSingle(5)");
        city.payIncomes();
        city.processCommand("bills");

        if (city.getTotalPopulation() == 0) {
            System.out.println("✔ Home removed if cannot pay");
        } else {
            System.out.println("✘ Home was not removed");
        }

        System.out.println("Manual tests finished.\n");
    }

    private static void assertEqual(double expected, double actual, String testName) {
        if (Math.abs(expected - actual) < 0.0001) {
            System.out.println("✔ " + testName);
        } else {
            System.out.println("✘ " + testName + " | Expected: "
                    + expected + " Actual: " + actual);
        }
    }
}

class Engine {

    private final Scanner scanner;
    private final SovietVille.City city;
    private int commandCounter;

    public Engine() {
        System.out.println("BREAKPOINT: Engine initialized");
        this.scanner = new Scanner(System.in);
        this.city = new SovietVille.City();
        this.commandCounter = 0;
    }

    public void run() {
        System.out.println("BREAKPOINT: Engine run started");

        while (true) {
            String input = scanner.nextLine().trim();
            System.out.println("BREAKPOINT: Read input -> " + input);

            if (input.equalsIgnoreCase("quit")) {
                System.out.println("BREAKPOINT: Quitting program");
                System.out.println("Total population: "
                        + city.getTotalPopulation());
                break;
            }

            try {
                city.processCommand(input);
                commandCounter++;
                System.out.println("BREAKPOINT: Command processed, counter = "
                        + commandCounter);

                if (commandCounter % 4 == 0) {
                    System.out.println("BREAKPOINT: Paying incomes");
                    city.payIncomes();
                }

            } catch (IllegalArgumentException ex) {
                System.out.println("Invalid command: "
                        + ex.getMessage());
            }
        }
    }
}

class SovietVille {

    static final double FRIDGE_COST = 1.5;
    static final double STOVE_COST = 1.2;
    static final double TV_COST = 1.0;
    static final double COMPUTER_COST = 0.7;

    static class City {

        private final List<Home> homes = new ArrayList<>();

        public void processCommand(String input) {

            if (input.startsWith("YoungCoupleWithChildren")) {
                homes.add(parseYoungCoupleWithChildren(input));
                return;
            }

            String command = input.contains("(")
                    ? input.substring(0, input.indexOf("("))
                    : input;

            switch (command) {
                case "YoungCouple" ->
                        homes.add(parseYoungCouple(input));
                case "YoungSingle" ->
                        homes.add(parseYoungSingle(input));
                case "OldCouple" ->
                        homes.add(parseOldCouple(input));
                case "OldSingle" ->
                        homes.add(parseOldSingle(input));
                case "status" -> printStatus();
                case "bills" -> payBills();
                default ->
                        throw new IllegalArgumentException("Unknown command");
            }
        }

        // ===== PARSING =====

        private YoungCouple parseYoungCouple(String input) {
            double[] values = extractDoubles(input, 2);
            return new YoungCouple(values[0], values[1]);
        }

        private YoungSingle parseYoungSingle(String input) {
            double[] values = extractDoubles(input, 1);
            return new YoungSingle(values[0]);
        }

        private OldCouple parseOldCouple(String input) {
            double[] values = extractDoubles(input, 2);
            return new OldCouple(values[0], values[1]);
        }

        private OldSingle parseOldSingle(String input) {
            double[] values = extractDoubles(input, 1);
            return new OldSingle(values[0]);
        }

        private YoungCoupleWithChildren parseYoungCoupleWithChildren(String input) {

            Pattern couplePattern =
                    Pattern.compile("YoungCoupleWithChildren\\(([^)]+)\\)");
            Matcher matcher = couplePattern.matcher(input);

            if (!matcher.find())
                throw new IllegalArgumentException("Invalid family format");

            String[] salaries =
                    matcher.group(1).split(",\\s*");

            double s1 = Double.parseDouble(salaries[0]);
            double s2 = Double.parseDouble(salaries[1]);

            YoungCoupleWithChildren home =
                    new YoungCoupleWithChildren(s1, s2);

            Pattern childPattern =
                    Pattern.compile("Child\\(([^)]+)\\)");
            Matcher childMatcher =
                    childPattern.matcher(input);

            while (childMatcher.find()) {

                String[] parts =
                        childMatcher.group(1).split(",\\s*");

                double food =
                        Double.parseDouble(parts[0]);

                List<Double> toys = new ArrayList<>();

                for (int i = 1; i < parts.length; i++) {
                    toys.add(Double.parseDouble(parts[i]));
                }

                home.addChild(
                        new Child(food, toys));
            }

            return home;
        }

        private double[] extractDoubles(String input, int expectedCount) {

            String inside =
                    input.substring(input.indexOf("(") + 1,
                            input.lastIndexOf(")"));

            String[] parts =
                    inside.split(",\\s*");

            if (parts.length != expectedCount)
                throw new IllegalArgumentException("Wrong parameter count");

            double[] result =
                    new double[expectedCount];

            for (int i = 0; i < parts.length; i++) {
                result[i] =
                        Double.parseDouble(parts[i]);
            }

            return result;
        }

        // ===== LOGIC =====

        public void payIncomes() {
            homes.forEach(Home::receiveIncome);
        }

        public void payBills() {

            Iterator<Home> iterator =
                    homes.iterator();

            while (iterator.hasNext()) {
                Home h = iterator.next();
                if (!h.payBills()) {
                    iterator.remove();
                }
            }
        }

        public void printStatus() {
            double total =
                    homes.stream()
                            .mapToDouble(Home::getMonthlyConsumption)
                            .sum();

            System.out.printf(
                    "Total consumption: %.2f%n", total);
        }

        public int getTotalPopulation() {
            return homes.stream()
                    .mapToInt(Home::getPopulation)
                    .sum();
        }
    }

    // ===== HOME BASE =====

    static abstract class Home {

        private final double income;
        private double budget;
        private final int rooms;
        private final double roomCost;

        protected Home(double income,
                       int rooms,
                       double roomCost) {
            this.income = income;
            this.rooms = rooms;
            this.roomCost = roomCost;
        }

        protected double getRoomsCost() {
            return rooms * roomCost;
        }

        public void receiveIncome() {
            budget += income;
        }

        public boolean payBills() {
            double monthly =
                    getMonthlyConsumption();
            if (budget >= monthly) {
                budget -= monthly;
                return true;
            }
            return false;
        }

        public double getBudget() {
            return budget;
        }

        abstract double getMonthlyConsumption();
        abstract int getPopulation();
    }

    // ===== HOME TYPES =====

    static class YoungCouple extends Home {
        public YoungCouple(double s1, double s2) {
            super(s1 + s2, 2, 20);
        }

        double getMonthlyConsumption() {
            return getRoomsCost()
                    + TV_COST
                    + FRIDGE_COST
                    + 2 * COMPUTER_COST;
        }

        int getPopulation() { return 2; }
    }

    static class YoungSingle extends Home {
        public YoungSingle(double salary) {
            super(salary, 1, 10);
        }

        double getMonthlyConsumption() {
            return getRoomsCost()
                    + COMPUTER_COST;
        }

        int getPopulation() { return 1; }
    }

    static class OldCouple extends Home {
        public OldCouple(double p1, double p2) {
            super(p1 + p2, 3, 15);
        }

        double getMonthlyConsumption() {
            return getRoomsCost()
                    + TV_COST
                    + FRIDGE_COST
                    + STOVE_COST;
        }

        int getPopulation() { return 2; }
    }

    static class OldSingle extends Home {
        public OldSingle(double pension) {
            super(pension, 1, 15);
        }

        double getMonthlyConsumption() {
            return getRoomsCost()
                    + STOVE_COST;
        }

        int getPopulation() { return 1; }
    }

    static class YoungCoupleWithChildren extends Home {

        private final List<Child> children =
                new ArrayList<>();

        public YoungCoupleWithChildren(
                double s1, double s2) {
            super(s1 + s2, 2, 30);
        }

        public void addChild(Child child) {
            children.add(child);
        }

        double getMonthlyConsumption() {
            double childrenCost =
                    children.stream()
                            .mapToDouble(
                                    Child::getMonthlyCost)
                            .sum();

            return getRoomsCost()
                    + TV_COST
                    + FRIDGE_COST
                    + 2 * COMPUTER_COST
                    + childrenCost;
        }

        int getPopulation() {
            return 2 + children.size();
        }
    }

    static class Child {

        private final double foodCost;
        private final double toysCost;

        public Child(double foodCost,
                     List<Double> toys) {
            this.foodCost = foodCost;
            this.toysCost =
                    toys.stream()
                            .mapToDouble(Double::doubleValue)
                            .sum();
        }

        public double getMonthlyCost() {
            return foodCost + toysCost;
        }
    }
}

